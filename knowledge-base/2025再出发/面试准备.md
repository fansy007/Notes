
# redis

## 缓存穿透 -- 
![[Pasted image 20250804092859.png]]
如果数据不存在，每次都要掉远程calling

-- redis中存一个 null

-- 布隆过滤器，拦截不存在的数据
![[Pasted image 20250804093115.png|950]]
bloomFilter

## 缓存击穿
一个key过期的时间 大量请求来了，并发把系统压垮了

-- 添加互斥锁
远程请求前，先加锁，如果有别的请求，要等这个锁解除了，从缓存中拿



-- 逻辑过期 不设置redis过期时间
而数据上添加过期时间

如果逻辑过期 加锁 开新线程重建数据&逻辑时间
但是线程一拿着旧的数据直接返回了

## 缓存雪崩
redis 大量的key同时过期，宕机，造成远程call的巨大开销

-- 不同的key设置不同的过期时间

-- 使用redis集群防止宕机

-- 限流 nginx

-- 多级缓存 guava caffeine


## 数据库数据和 redis 双写一致性

删数据时要延时双删
先删缓存 该数据库 延时再删一次缓存


读写锁 -- 读锁 （加了之后 其他线程可读不可写）
		写锁  （加了之后 其他线程不可读写）

强一致性业务时使用

---
异步通知方式更新缓存 -- 非强一致性时使用 （canal）


## redis的持久化问题
RDB AOF

redis备份backup file

redis-cli
bgsave

可以用redis.conf
![[Pasted image 20250804102358.png|600]]

AOF append only file
每一个写命令都记录到一个AOF文件 默认是关闭的
![[Pasted image 20250804103131.png|650]]


## 数据过期策略

惰性删除策略 get时发现过期才删数据

定期删除 定期检查一定量的数据
slow 模式 默认每秒执行10次，每次不超过25ms
fast模式 两次间隔不低于 2ms 每次耗时不超过1ms

以上两种过期策略可以同时存在

## 数据淘汰策略
当redis内存不够用时 添加新的key时如何淘汰

noeviction -- 满了之后不再写入新的
volatile-ttl -- 过期时间短优先淘汰

LRU 最近最少使用
LFU 最少频率 

以上是缓存相关的所有内容

--- 
## 分布式锁

同一个service发布在不同的cluster时，在一台机器上加锁 synchronized时不够的，要用分布式锁。

setnx命令设过期时间防止死锁 比如设了锁的时候死机了，过期释放
redission 
1.有watch dog 每间隔 releaseTime/3做一次续期
2.加锁时有while循环，设置了一定循环次数，等待锁的释放

![[Pasted image 20250805084349.png|350]]
两个方法在同一个线程，两个方法将使用同一个锁
![[Pasted image 20250805084547.png|450]]

### redlock
会在多个redis节点上加锁，哨兵模式时，永远用加锁的节点成为master

## 集群方案
主从
哨兵
分片

### 主从 master -- replica

全量同步

master负责写 replica负责读
master写的时候，要同步到replica
主从节点对齐repid version， master生成RDB，同时在dump期间记录baklog replica加载RDB再加载baklog（有offset标记 baklog从哪里开始同步）

增量同步 例如从节点重启了
		还是同步 rep_baklog offset之后的数据

### 哨兵模式（sentinel）
监控集群状态，自动状态恢复（当master宕机时，选一个从节点当作主节点）

sentinal 每隔1秒 ping每隔实例。如果多个哨兵同时ping不通那就是客观下线了。通过一定的机制选一个从节点做主节点。 offset越大，和主节点数据同步性越高。

脑裂问题的解决 --
至少要有一个replica
主从同步延迟不得超过5秒

不满足时停止向master写数据

### 海量数据的解决 分片
多个master 每个master保存不同数据
每个master有自己的replica

master之间通过ping互相监控，客户端call时，master节点之间可以路由，把client导向正确的master节点

![[Pasted image 20250805093620.png|450]]

## IO多路复用
NIO -- 单个线程监听多个socket，当有一个socket ready时， 分配给client这个socket去做操作，在没有socket的时候，除了监听线程没有别的开销。

# Spring
spring bean默认是单例的，非线程安全
singeton -- prototype

成员变量，如果被多个线程修改，会有线程安全问题
（有状态，无状态 成员变量 -- 该成员变量能不能被修改）

## AOP
日志 -- 把请求 操作时间等等发到elk去（包括otel）（也可以使用拦截器）
缓存
事务

声明式事务

## 事务失效的场景
异常捕获处理
如果错误没有抛出，事务就不会回滚了

抛出了一个非RuntimeException，spring默认只回滚runtime exception
![[Pasted image 20250805104131.png|375]]
非public方法导致事务无效

## spring bean 的生命周期
BeanDefinition对象 -- 当创建bean对象时，可以根据这个类反射把bean class实例创建出来

![[Pasted image 20250805105254.png]]
spring的循环依赖问题
二级缓存 earlySingletonObjects对象 -- bean的依赖还没有注入就已经放在缓存里了
三级缓存 singletonFacctoryObjects -- 如果bean是一个factory代理对象放到这个缓存中

但是构造方法 用构造器注入依赖时，循环依赖是无法解决的
必须使用 @Lazy延时加载才能解决问题

# springMVC

老的 JSP

![[Pasted image 20250806085910.png]]



![[Pasted image 20250806090151.png]]

# springboot
@AotuConfiguration 的原理

![[Pasted image 20250806091408.png]]

类似于java spi 机制 （service provider interface）
例如JDBC加载

有接口 JDBCDriver
厂商或服务商实现借口，比如 oracleJDBCDriver
厂商把 oracleJDBCDriver配置在meta-info的配置文件里

java 有 JDBC loader通过读classpath中的配置，或者代码中的class.forName XXX 决定使用具体哪一个驱动

# 常用注解
 ![[Pasted image 20250806093150.png]]
![[Pasted image 20250806093359.png]]

![](app://27d972d7eaf08315f98df329f9a99f1f7adf/Users/hg26502/Library/Mobile%20Documents/iCloud~md~obsidian/Documents/Notes/knowledge-base/spirng-boot/Pasted%20image%2020231007195139.png?1696679499440)

# Mybatis
![[Pasted image 20250806094724.png]]

延迟加载
fetchType='Lazy'
级联查询时，不查询链接表

原理是 getOrderList entity本身是cglib的代理对象，调用get方法时会看看是不是为空，为空会调一次sql查询

## 缓存
perpetual cache
一级缓存是sesion级别的
二级缓存是namespace和mapper级别的

session缓存 当 flush或close后，缓存清空
二级缓存默认是关闭的，需要打开 cacheEnable

# JMS
publish有日志 -- 日志被导向elk，失败了可以捞request重发
消息的持久化 queue，重启messgae不消失
consumer端有 ack nack

## 重复消费问题
设置唯一的id guiId 

## 延迟队列
进入队列的消息会被延迟消费

死信 ttl超时无人消费 -》把消息转发到死信交换机 -〉投入新的queue

## 消费堆积怎么处理
增加消费者
在消费者上开线程池
增加队列容积

## 集群
镜像集群。在mq的各个镜像节点，数据会同步

# kafka
kafka消息可以设置重试次数

集群 + 分区复制机制 = 高可用性
![[Pasted image 20250806112053.png]]

kfka的topic数据 存在不同的分区上，分区如果文件过大会分段存储 segment
那个分段有 index 和log 文件

### kafka高性能的原因
消息分区
顺序读写 （offset 标记位置）
页缓存 （磁盘-》内存）
零拷贝
数据压缩
分批发送 打包发送 减少网络开销

# 集合
![[Pasted image 20250807151556.png|400]]
## 在一个数组中找一个数字 
遍历查找复杂度是 O(n)
排序后两分查找是 O(log(n))

插入和删除是 需要挪动整个数组 平均复杂度是 O(n)

ArrayList 底层是一个动态的数组
初识容量为0，第一次添加数据时，容量为10
当添加11个数据时，会给数组扩容到15

![[Pasted image 20250807161559.png|500]]

Arrays.asList 把数组转ArrayList，当 传入的数组中的值改了，ArrayList中的值也会被影响

list.toArray(new String[size]),把List转数组时，不会受到影响，因为会建一个新的数组返回

LinkedList
![[Pasted image 20250807162401.png]]
insert  delete复杂度是 O(n),主要的时间是找数据

在方法内使用，只有1分，是线程安全的
作为成员变量，要安全必须加锁

## Map
![[Pasted image 20250807164009.png|500]]
查找效率 O(log(n))

红黑树是平衡的二叉树
插入数据时，需要旋转再次平衡

### hash
![[Pasted image 20250807165437.png|875]]


当多个key映射到了同一个下标时，会出现hash冲突，解决办法

拉链法 一个下标存多个值
   
 ![[Pasted image 20250807170112.png|725]]


寻址方法
先hash，然后二次hash 右移16位亦或 试分布更加均匀

# 线程
创建线程
Callable对象 -》传入FutureTask FutureTask传入-〉Thread

线程池的方式创建线程

callable 接口是可以抛出异常的
runnable接口是不可以抛出异常的

线程的六个状态
NEW,RUNNABLE,WAITING,BLOCKED,TIMED_WAIT,TERMINATED

线程调用wait方法后进入等待，然后其他线程调notify再次激活
线程内sleep进入 TIMED_WAIT,sleep结束再次唤起

![[Pasted image 20250810123714.png|800]]

## 如何让三个线程按顺序执行
使用join方法，调用次方法的线程将等待被调用的线程运行结束后继续执行

![[Pasted image 20250810124203.png|300]]

## notify notifyAll方法

notify唤醒sleep线程

## wait 和 sleep的不同
wait方法是被锁调用的 sleep是Thread的静态方法
调wait notify时锁被释放

```java
CountDownLatch latch = new CountDownLatch(2);
Thread t = new Thread(()->{
	try {
		System.out.println("start to run");
		synchronized (Lock.class) {
			latch.countDown();
			latch.countDown();
			Lock.class.wait();
			System.out.println("wait complete");
		}
	} catch (InterruptedException e) {
		throw new RuntimeException(e);
	}
});

t.start();
latch.await();
synchronized (Lock.class) {
	System.out.println("get the main thread");
	Lock.class.notify();
}
```

## 中断线程 interrupt
当打断一个阻塞的线程时，会抛异常

当打断一个运行的线程时通过flag的变化操作

```java
    Thread t = new Thread(()->{  
        System.out.println("Thread starting");  
        int i = 0;  
        try {  
            while(true) {  
                i++;  
                if(Thread.currentThread().isInterrupted()) {  
                    System.out.println(String.format("Total count is %d",i));  
                    break;  
                }  
            }  
        } catch (Exception e) {  
            throw new RuntimeException(e);  
        }  
    });  
  
    t.start();  
    Thread.sleep(1000);  
    t.interrupt();  
}
```

## synchronize底层机制
底层是monitor
![[Pasted image 20250810133602.png|900]]
使用synchronize是 lock object的markword 会指向一个monitor如上图

Java中的`synchronized`关键字通过**锁升级机制**​（偏向锁→轻量级锁→重量级锁）优化多线程性能，不同锁状态针对不同竞争场景设计。